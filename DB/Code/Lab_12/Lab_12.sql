ALTER PLUGGABLE DATABASE FIA_PDB OPEN;

ALTER PLUGGABLE DATABASE FIA_PDB CLOSE IMMEDIATE;

grant create any trigger, drop any trigger to FIA;


--1: Create a table with some fields one of which is a primary key
create table Product(
    product_id number generated by default as identity primary key,
    product_name nvarchar2(20) not null,
    price number(10,2) default 0 check(price>=0)
);

drop table Product purge;

--2:Fill previously created table with 10 lines

delete Product;

INSERT INTO Product (product_name, price) VALUES (N'Notebook', 799.99);
INSERT INTO Product (product_name, price) VALUES (N'Smartphone', 499.50);
INSERT INTO Product (product_name, price) VALUES (N'Headphones', 89.90);
INSERT INTO Product (product_name, price) VALUES (N'Keyboard', 45.00);
INSERT INTO Product (product_name, price) VALUES (N'Mouse', 25.75);
INSERT INTO Product (product_name, price) VALUES (N'Monitor', 199.95);
INSERT INTO Product (product_name, price) VALUES (N'External HDD', 129.00);
INSERT INTO Product (product_name, price) VALUES (N'Laptop Stand', 39.99);
INSERT INTO Product (product_name, price) VALUES (N'Webcam', 59.49);
INSERT INTO Product (product_name, price) VALUES (N'USB Hub', 19.90);

commit;

select * from Product;

--3: create a BEFORE operator-level trigger for INSERT,UPDATE,DELETE
create or replace trigger OPERATOR_BEFORE
before insert or update or delete on Product
begin
    if inserting then
        dbms_output.put_line('Insert trigger OPERATOR_BEFORE was triggered');
    elsif updating then
        dbms_output.put_line('Update trigger OPERATOR_BEFORE was triggered');
    elsif deleting then
        dbms_output.put_line('Delete trigger OPERATOR_BEFORE was triggered');
    end if;
end;

--4: create a BEFORE row-level trigger for INSERT,UPDATE,DELETE
create or replace trigger ROW_BEFORE
before insert or update or delete on Product
for each row
begin
    if inserting then
        dbms_output.put_line('Insert trigger ROW_BEFORE was triggered');
    elsif updating then
        dbms_output.put_line('Insert trigger ROW_BEFORE was triggered');
    elsif deleting then
        dbms_output.put_line('Insert trigger ROW_BEFORE was triggered');
    end if;
end;

--5: create an operator-level AFTER trigger for INSERT, UPDATE,DELETE

create or replace trigger OPERATOR_AFTER
after insert or update or delete on Product
begin
    dbms_output.put_line('OPERATOR_AFTER trigger triggered');
end;

--6: create a row-level AFTER trigger for INSERT,UPDATE,DELETE
create or replace trigger ROW_AFTER
after insert or update or delete on Product
for each row
begin
    if inserting then
        dbms_output.put_line('INSERT ROW_AFTER trigger triggered');
    elsif updating then
        dbms_output.put_line('UPDATE ROW_AFTER trigger triggered');
    elsif deleting then
        dbms_output.put_line('DELETE ROW_AFTER trigger triggered');
    end if;
end;

--7: create AUDIT table

create table AUDIT_LOG(
operationDate Date,
operationType varchar2(10),
triggerName varchar2(20),
Data varchar2(100)
);

drop table AUDIT_LOG purge;


--8: alter all previously created triggers for them to work with AUDIT_LOG table

create or replace trigger OPERATOR_BEFORE
before insert or update or delete on Product
declare
     operation audit_log.operationtype%type;
begin
    if inserting then
        dbms_output.put_line('Insert trigger OPERATOR_BEFORE was triggered');
        operation:='insert';
    elsif updating then
        dbms_output.put_line('Update trigger OPERATOR_BEFORE was triggered');
        operation:='update';
    elsif deleting then
        dbms_output.put_line('Delete trigger OPERATOR_BEFORE was triggered');
        operation:='delete';
    end if;
    
    insert into audit_log values(sysdate, operation, 'OPERATOR_BEFORE', null);
end;


create or replace trigger ROW_BEFORE
before insert or update or delete on Product
for each row
declare
    operation audit_log.operationtype%type;
    data audit_log.data%type;
begin
    if inserting then
        operation := 'insert';
        data := :new.product_id || :new.product_name || :new.price;
        dbms_output.put_line('Insert trigger ROW_BEFORE was triggered');
    elsif updating then
        operation := 'update';
        data := :new.product_id || :new.product_name || :new.price;
        dbms_output.put_line('Insert trigger ROW_BEFORE was triggered');
    elsif deleting then
        operation := 'delete';
        data := :new.product_id || :new.product_name || :new.price;
        dbms_output.put_line('Insert trigger ROW_BEFORE was triggered');
    end if;
    insert into audit_log values (sysdate, operation, 'ROW_BEFORE', data);
end;



create or replace trigger OPERATOR_AFTER
after insert or update or delete on Product
declare
  operation audit_log.operationtype%type;
begin
   if inserting then
        dbms_output.put_line('Insert trigger OPERATOR_AFTER was triggered');
        operation:='insert';
    elsif updating then
        dbms_output.put_line('Update trigger OPERATOR_AFTER was triggered');
        operation:='update';
    elsif deleting then
        dbms_output.put_line('Delete trigger OPERATOR_AFTER was triggered');
        operation:='delete';
    end if;
     insert into audit_log values(sysdate, operation, 'OPERATOR_AFTER', null);    
end;


create or replace trigger ROW_AFTER
after insert or update or delete on Product
for each row
declare
     operation audit_log.operationtype%type;
    data audit_log.data%type;
begin
    if inserting then
        operation := 'insert';
        data := :new.product_id || :new.product_name || :new.price;
        dbms_output.put_line('INSERT ROW_AFTER trigger triggered');
    elsif updating then
        operation := 'update';
        data := :new.product_id || :new.product_name || :new.price;
        dbms_output.put_line('UPDATE ROW_AFTER trigger triggered');
    elsif deleting then
        operation := 'delete';
        data := :new.product_id || :new.product_name || :new.price;
        dbms_output.put_line('DELETE ROW_AFTER trigger triggered');
    end if;
     insert into audit_log values (sysdate, operation, 'ROW_AFTER', data);
end;


--9: execute an operation that will violate PRIMARY KEY
select * from AUDIT_LOG;

insert into Product values (1,'violation_test',1);

--10:drop Product table and create trigger that will prohibit table drop

drop table Product purge;
drop trigger DROP_TABLE_TRIGGER;

create or replace trigger DROP_TABLE_TRIGGER
before drop on schema
begin
    if (ORA_DICT_OBJ_NAME = 'PRODUCT') then
        raise_application_error(-20000, 'Failed to drop due to trigger ' || ORA_DICT_OBJ_TYPE || ' ' || ORA_DICT_OBJ_NAME);
    end if;
end;

--11:drop AUDIT_LOG table. Look through triggers state via SQLDEVELOPER. Alter triggers

alter trigger OPERATOR_BEFORE compile;
alter trigger ROW_BEFORE compile;
alter trigger OPERATOR_AFTER compile;
alter trigger ROW_AFTER compile;


drop table AUDIT_LOG;
flashback table AUDIT_LOG to before drop;

--12: create a view for Product table. Develop INSTEADOF INSERT trigger

drop view vProduct;

create view vProduct
as
select product_id, product_name, price from Product;

create or replace trigger INSTEAD_INSERT
instead of update or insert or delete on vProduct
declare
    data varchar2(20);
begin
    data := :new.product_id || :new.product_name || :new.price;
    if(:new.product_id is null) then 
        insert into Product(product_name, price) values ( :new.product_name, :new.price);
    else
        insert into Product values (:new.product_id, :new.product_name, :new.price);
    end if;
end;

insert into vProduct(product_name, price) values ('view_test','1000');
select * from Product;









