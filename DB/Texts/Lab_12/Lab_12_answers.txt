1.	Перечислите типы триггеров, поддерживаемых Oracle.

    DML‑триггеры: BEFORE/AFTER/INSTEAD OF для INSERT, UPDATE, DELETE.
    Триггеры уровня строки (FOR EACH ROW) и уровня оператора (без FOR EACH ROW).
    INSTEAD OF‑триггеры для представлений (VIEW).
    Триггеры схемы (Schema-level): ON SCHEMA — реагируют на DDL‑события и события входа/выхода сессии (логон/логoff) и т.д.
    Системные триггеры (Database-level): ON DATABASE — реагируют на события на уровне БД (например, LOGON/LOGOFF, DDL во всей базе).

2.	Можно ли выполнять TCL-операторы в триггерах Oracle. Если да, то при каких условиях?
Нельзя вызывать COMMIT/ROLLBACK внутри самого триггера, который является частью основной транзакции; попытка привестиёт к ошибке.
(Ну либо можно вызвать из автономной транзакции внутри триггера PRAGMA AUTONOMOUS_TRANSACTION)

3.	Поясните правило: триггер является частью транзакции.

    Триггер выполняется внутри той же транзакции, что и DML‑операция, вызвавшая его (если только не используется автономная транзакция).
    Следствие: все изменения, сделанные триггером (INSERT/UPDATE/DELETE), будут зафиксированы или отменены вместе с основной транзакцией; COMMIT/ROLLBACK основной транзакции распространяются на изменения триггера.
    Это обеспечивает атомарность: либо всё (операция + триггеры) коммитится, либо всё откатывается.

4.	Перечислите привилегии необходимые для работы с триггерами. 
CREATE TRIGGER или CREATE ANY TRIGGER, 
5.	Перечислите события, на которые могут срабатывать DML-триггеры.
INSERT — срабатывает при добавлении строк.
UPDATE — при изменении строк (можно ограничить конкретными колонками).
DELETE — при удалении строк.
(И также их комбинация через OR: INSERT OR UPDATE OR DELETE)

6.	Объясните, что такое BEFORE-триггеры и AFTER-триггеры. 
BEFORE‑триггер: выполняется до фактической операции DML (до вставки/обновления/удаления строки)
AFTER‑триггер: выполняется после успешного выполнения DML‑операции (после того как значения в таблице помечены для записи). 

7.	В каких случаях нельзя обойтись только BEFORE-триггерами или только AFTER-триггерами?
Когда нужно и корректировать входящие данные, и затем выполнить действия, зависящие от результата записи: 
корректировку (или валидацию) делают в BEFORE (чтобы изменить :NEW), а финальную обработку/логирование — в AFTER (чтобы быть уверенным, что операция выполнена).

8.	Перечислите уровни срабатывания триггеров.

    Statement‑level (уровень оператора): триггер срабатывает один раз для всей DML‑операции, независимо от числа затронутых строк (без FOR EACH ROW).
    Row‑level (уровень строки): триггер срабатывает для каждой затронутой строки (FOR EACH ROW) и имеет доступ к :NEW и :OLD.
    В дополнение: в схемных/системных триггерах — уровень может быть SCHEMA или DATABASE (события на уровне схемы/базы).

9.	Поясните принцип применения INSTEADOF-триггеров в Oracle.

    INSTEAD OF-триггеры назначаются на представления (VIEW) и выполняются вместо DML‑операции над ними. Позволяют реализовать вставку, обновление или удаление "в" представление,
     преобразуя операцию в соответствующие изменения базовых таблиц.
    Применяются для обновляемых/необновляемых представлений, где напрямую DML не поддерживается — INSTEAD OF даёт программируемую логику, как транслировать DML во множественные базовые таблицы.
    INSTEAD OF‑триггер не используется для обычных таблиц.

10.	Что такое мутирование таблиц?
Ошибка «table is mutating» возникает, когда триггер уровня строки пытается прочитать/изменить ту же таблицу (обычно через SELECT на неё или изменение) в середине операции DML, 
пока таблица ещё находится в состоянии изменения — это нарушает целостность данных и последовательность операций.
