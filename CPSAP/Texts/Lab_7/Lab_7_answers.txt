1. MIME — что это, кто поддерживает, где используется

MIME — аббревиатура от Multipurpose Internet Mail Extensions.
Определение: это набор правил для обозначения типа и формата данных в интернете (тип/подтип + опциональные параметры), например text/html;charset=utf-8.

Стандарты и регистрация типов MIME ведёт IANA (Internet Assigned Numbers Authority) — официальный реестр медиа-типов.
Спефикации и рекомендации публикуют IETF (через RFC), разработчики браузеров и серверных платформ (W3C, WHATWG, крупные вендоры) следуют этим RFC и IANA-реестру.


Где в HTTP используется MIME:

    В заголовке ответа Content-Type указывается MIME-тип ресурса (например Content-Type: application/json; charset=utf-8). Это указывает клиенту, как интерпретировать тело ответа.
    В заголовке запроса Accept клиент сообщает серверу приемлемые MIME-типы (Accept: text/html, application/json). Сервер может учитывать это при выборе формата ответа.
    Также используются заголовки Content-Type при отправке тела запроса (POST/PUT) и Accept-Encoding/Content-Encoding для кодировок; параметризованные типы встречаются в multipart (например multipart/form-data; boundary=...).


2. Теги HTML, интерпретация которых приводит к HTTP-запросам


    Основные теги, которые автоматически инициируют HTTP-запросы при разборе/рендеринге страницы:
        <img src="..."> — скачивает изображение.
        <script src="..."> — загружает JS-файл.
        <link rel="stylesheet" href="..."> — при rel="stylesheet" загружает CSS.
        <video> / <audio> с <source src="..."> — загружает медиа-потоки (поддерживает Range-запросы).
        <iframe src="..."> — загружает вложенную страницу.
        <embed> / <object data="..."> — загружает внешние ресурсы/плагины.
        <source src="..."> (в <picture> или медиа-тегах) — загрузка альтернативных ресурсов.
        <link rel="preload" href="...">, <link rel="prefetch">, <link rel="dns-prefetch"> — инициируют предзагрузку/предвыборку ресурсов/доменов.
        <form action="..." method="..."> при отправке формы инициирует HTTP-запрос (обычно по клику или программно).
    Дополнительно, CSS внутри url(...) (например background-image: url(...)) и шрифты (@font-face) также приводят к HTTP-запросам на соответствующие URL.

3. Способы выполнения HTTP-запросов из JS-сценария

    В браузере:
        fetch API — современный промис-ориентированный метод: fetch(url, options). Поддерживает потоковые ответы, управление заголовками, режимы CORS и т.д.
        XMLHttpRequest (XHR) — старый, но всё ещё используемый API для асинхронных запросов; поддерживает прогресс, синхронные/асинхронные вызовы.
        Form submission — отправка формы (в т.ч. programmatic form submit) инициирует навигацию/запрос.
        WebSocket / Server-Sent Events (SSE) — не HTTP-запросы в классическом смысле, но устанавливают соединения поверх HTTP/HTTPS (handshake) и используются для двунаправленного обмена/серверных событий.
        img/script/link tags / dynamic DOM creation — создание элементов с src/href программно приводит к загрузке (например let s = document.createElement('script'); s.src = ...; document.head.appendChild(s)).
        Beacon API (navigator.sendBeacon) — для фоновой отправки коротких данных (например аналитика) без блокировки выгрузки страницы.
    В Node.js (серверный JS):
        http/https modules — встроенные модули http.request / https.request.
        fetch — в современных Node.js (или с polyfill) доступен глобальный fetch.
        Библиотеки: axios, node-fetch, got и т.п. — удобные высокоуровневые клиенты с промисами/await, таймаутами, автоматическим парсингом и т.д.

3. Что такое «параметризованный модуль»


    Определение: параметризованный модуль — модуль (файл/библиотека), который при инициализации принимает один или несколько параметров/опций и возвращает функцию, объект или обработчик, настроенный под эти параметры. То есть модуль не использует «жёстко» встроённые значения, а позволяет настраивать поведение извне.
    Примеры и свойства:
        В Node.js часто экспортируют фабричную функцию: module.exports = function createThing(options) { ... return handler; }. При вызове createThing({ root: 'static' }) получают экземпляр с заданной конфигурацией.
        Параметризованный модуль упрощает повторное использование, тестирование и инверсию управления (dependency injection).
        В вашем задании модуль 07-01m.js является параметризованным: он экспортирует функцию createStaticHandler(staticRootRelative), принимающую путь к корню static и возвращающую обработчик HTTP-запросов, привязанный к этому корню.
