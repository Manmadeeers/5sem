
    TCP‑порт

    Определение: числовой идентификатор (16‑бит, 0–65535) в заголовке транспортного уровня (TCP/UDP), который вместе с IP‑адресом формирует уникальную конечную точку (socket) на хосте.
    Назначение: позволяет различать несколько сетевых служб/приложений на одном IP‑адресе (например, HTTP обычно на порту 80, HTTPS — 443).
    Особенности: порты <1024 традиционно «зарезервированы» для системных служб; приложения слушают порт (bind/listen) и принимают входящие соединения на нём.

    Сетевой сокет

    Определение: абстракция конечной точки сетевого соединения, задаваемая как кортеж (протокол, локальный IP, локальный порт, удалённый IP, удалённый порт). В прикладном программировании «сокет» — это объект/дескриптор, через который приложение отправляет и получает байты по сети.
    Роли: сервер создаёт слушающий (listening) сокет для принятия входящих соединений; при принятии создаётся новый сокет для обмена с конкретным клиентом.
    Примеры операций: bind, listen, accept, connect, send, recv, close.

    WebSocket

    Определение: протокол двунаправленной, постоянной связи поверх TCP (RFC 6455), обеспечивающий канал между браузером (или другим клиентом) и сервером, где обе стороны могут в любой момент отправлять сообщения.
    Особенности: устанавливается через начальный HTTP(S) «handshake» (Upgrade: websocket), после чего соединение «переключается» в двунаправленный бинарно/текстовый поток фреймов. Поддерживает низкую задержку и постоянное соединение (long‑lived).
    Использование: чаты, телеметрия, уведомления в реальном времени, игры и пр.

    Процедура установки соединения между WS‑сервером и WS‑клиентом

    Клиент инициирует HTTP/HTTPS запрос с заголовками для перехода на WebSocket: GET /path HTTP/1.1, Upgrade: websocket, Connection: Upgrade, Sec-WebSocket-Key, Sec-WebSocket-Version и т.д.
    Сервер проверяет заголовки и, если согласен, возвращает ответ с кодом 101 Switching Protocols и заголовком Sec-WebSocket-Accept, который — валидация ключа клиента (SHA‑1 + base64).
    После успешного handshake TCP‑соединение остаётся открытым, и стороны обмениваются WebSocket‑фреймами (текст/бинарные/ping/pong/close).
    Закрытие: инициатор посылает фрейм close, другая сторона отвечает close и затем закрывается TCP‑сокет.

    Широковещательное сообщение

    Определение: сообщение, адресованное группе получателей одновременно. В сетях есть аппаратные/протокольные понятия broadcast (например, Ethernet broadcast, IP‑broadcast 255.255.255.255). В прикладных системах это часто реализуется как «рассылка всем подписчикам» (publish to all).
    Назначение: эффективное оповещение множества клиентов (например, обновление состояния, уведомления).
    Замечание: на уровне WebSocket «широковещание» реализует сам сервер, отправляя одно и то же уведомление всем подключённым/подписанным клиентам — это не сетевой broadcast в низкоуровневом смысле.

    Принцип организации потокового ввода/вывода через WS‑соединение

    Фреймы: данные передаются в виде последовательности фреймов WebSocket (текстовые или бинарные), каждый фрейм содержит заголовок и полезную нагрузку.
    Потоковая модель: соединение — двунаправленное и полно‑дуплексное: клиент и сервер могут одновременно писать и читать. Приложение читает/обрабатывает приходящие фреймы и отправляет фреймы в нужный момент.
    Фрагментация и сборка: крупные сообщения могут разбиваться на фрагменты, принимающая сторона собирает их в полное сообщение.
    Поток ввода: обработка входящих событий/колбэков (onmessage).
    Поток вывода: синхронный или асинхронный вызов отправки (send), часто с очередью и контролем состояния соединения (readyState).

    Механизм «ping/pong» — принцип действия и назначение

    Назначение: поддерживать проверку живости (liveness) соединения и обнаруживать «мертвые» соединения; также помогает обходить NAT/файрволлы (поддерживать активность).
    Как работает: одна сторона отправляет контролирующий фрейм ping; вторая автоматически отвечает pong (может содержать ту же полезную нагрузку). Реализованные библиотеки обычно обрабатывают ping/pong автоматически или позволяют регистрировать обработчики.
    Использование: сервер периодически посылает ping клиенту; отсутствие ответа в пределах таймаута — повод разорвать соединение и очистить ресурсы.

    Аббревиатура «RPC»

    RPC = Remote Procedure Call — вызов удалённой процедуры/функции, где программа вызывает функцию, расположенную на удалённой системе, как будто локальную, а механизм RPC занимается обменом сообщениями, сериализацией параметров и результатом.

    Принцип работы RPC‑механизма, предоставляемого пакетом rpc‑websockets

    Модель: над WebSocket реализован JSON‑RPC‑подобный механизм: сервер регистрирует именованные методы (register(name, handler)), клиенты вызывают их через call(name, params) и получают промис с результатом.
    Notifications/events: пакет также предоставляет механизм публикации событий: сервер может event(name, payload) и клиенты подписаться subscribe(name), получать уведомления через on(name, handler).
    Аутентификация и права: есть поддержка setAuth для проверки логина/пароля и методы можно помечать как public() или protected() (в зависимости от версии/реализации).
    Транспорт: весь обмен происходит в пределах открытого WebSocket‑сокета — JSON‑сообщения с идентификаторами запросов/ответов, ошибками и результатами.

    Механизм «subscriber/publisher» (pub/sub) — принцип действия и назначение

    Назначение: асинхронная архитектура обмена сообщениями, где отправитель (publisher) не знает конкретных получателей; получатели (subscribers) подписываются на темы/топики и получают сообщения от всех издателей в этой теме.
    Принцип: издатель публикует сообщение в тему; брокер/сервер распределяет его всем подписчикам темы. Это обеспечивает слабую связанность компонентов, масштабируемость и гибкие рассылки.
    Примеры использования: уведомления, телеметрия, события UI, системы очередей.

    Механизм уведомлений — принцип действия и назначение

    Определение: уведомление — одностороннее сообщение о событии, обычно без ожидаемого прямого ответа (fire‑and‑forget). В контексте RPC/WS — это notification/emit/event, которое сервер отправляет подписанным клиентам.
    Назначение: быстро оповещать клиентов о произошедших изменениях (изменение состояния, новые данные, ошибки, события времени).
    Отличие от RPC: RPC подразумевает запрос → ответ; уведомление обычно не требует ответа и оптимально для широковещательных оповещений.
    Надёжность: уведомления могут быть «мягче» по гарантиям доставки; если требуется гарантированная доставка — применяют дополнительные механизмы (подтверждения, очереди, повторная доставка).

Summary:

    TCP‑порт и сокет — фундаментальные элементы идентификации и передачи данных на транспортном уровне;
    WebSocket расширяет TCP для постоянного двунаправленного обмена; handshake переводит HTTP в WS;
    ping/pong используются для контроля живости соединений;
    RPC делает вызовы удалённых функций удобными, а пакет rpc‑websockets реализует JSON‑RPC‑подобный интерфейс поверх WS и добавляет pub/sub‑уведомления;
    pub/sub и уведомления позволяют эффективно распространять события многим подписчикам без жёсткой связи между компонентами.
